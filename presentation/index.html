<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Lightweight - C++23 ODBC SQL Wrapper</title>

    <link rel="stylesheet" href="node_modules/reveal.js/dist/reset.css">
    <link rel="stylesheet" href="node_modules/reveal.js/dist/reveal.css">
    <link rel="stylesheet" href="node_modules/reveal.js/dist/theme/simple.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/foundation.min.css">

    <style>
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Fira+Code:wght@400;500&display=swap');

      .reveal {
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        font-size: 32px;
        font-weight: 400;
        line-height: 1.5;
      }
      .reveal h1, .reveal h2, .reveal h3, .reveal h4 {
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        font-weight: 600;
        line-height: 1.2;
        letter-spacing: -0.02em;
      }
      .reveal h1 { font-size: 2.2em; }
      .reveal h2 { font-size: 1.6em; }
      .reveal h3 { font-size: 1.3em; }
      .reveal h4 { font-size: 1.1em; }
      .reveal p, .reveal li {
        font-size: 0.9em;
        line-height: 1.6;
      }
      .reveal ul, .reveal ol {
        display: block;
        margin-left: 1em;
      }
      .reveal li {
        margin-bottom: 0.5em;
      }
      .reveal pre {
        width: 100%;
        font-size: 0.5em;
        font-family: 'Fira Code', 'Consolas', 'Monaco', monospace;
        box-sizing: border-box;
      }
      .reveal pre code {
        max-height: 550px;
        padding: 15px;
        font-family: 'Fira Code', 'Consolas', 'Monaco', monospace;
        line-height: 1.4;
        font-size: 1.6em;
      }
      .reveal table {
        font-size: 0.85em;
      }
      .reveal strong {
        font-weight: 600;
      }
      /* All code lines - consistent left border space */
      .reveal pre code .hljs-ln-line,
      .reveal pre code tr {
        border-left: 4px solid transparent;
      }
      /* Highlighted code lines */
      .reveal pre code .hljs-ln-line.highlight-line,
      .reveal pre code tr.highlight-line {
        background-color: rgba(184, 255, 181, 0.7);
        border-left: 4px solid #f5a623;
      }
      /* Non-highlighted lines when stepping through */
      .reveal pre code[data-line-numbers-showing] .hljs-ln-line:not(.highlight-line),
      .reveal pre code[data-line-numbers-showing] tr:not(.highlight-line) {
        opacity: 0.4;
      }
      /* Gantt Timeline styles */
      .gantt-container {
        display: flex;
        flex-direction: column;
        gap: 2em;
        margin-top: 0.5em;
      }
      .author-gantt {
        background: #f8f9fa;
        border-radius: 12px;
        padding: 1em 1.5em;
      }
      .author-gantt h3 {
        margin: 0 0 0.8em 0;
        font-size: 1.1em;
        color: #2c3e50;
      }
      .gantt-chart {
        position: relative;
        font-size: 0.55em;
      }
      .gantt-header {
        display: flex;
        border-bottom: 2px solid #dee2e6;
        padding-bottom: 0.5em;
        margin-bottom: 0.5em;
        margin-left: 80px;
      }
      .gantt-year {
        flex: 1;
        text-align: center;
        font-weight: 600;
        color: #6c757d;
      }
      .gantt-row {
        display: flex;
        align-items: center;
        height: 36px;
        margin-bottom: 4px;
      }
      .gantt-label {
        width: 80px;
        font-weight: 600;
        font-size: 0.95em;
        color: #495057;
      }
      .gantt-bars {
        flex: 1;
        position: relative;
        height: 28px;
        background: repeating-linear-gradient(
          90deg,
          transparent,
          transparent calc(100% / 11 - 1px),
          #e9ecef calc(100% / 11 - 1px),
          #e9ecef calc(100% / 11)
        );
      }
      .gantt-bar {
        position: absolute;
        height: 24px;
        top: 2px;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: 600;
        font-size: 0.9em;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      }
      .lang-cpp { background: linear-gradient(135deg, #667eea, #764ba2); }
      .lang-delphi { background: linear-gradient(135deg, #ee0979, #ff6a00); }
      .lang-ruby { background: linear-gradient(135deg, #6495ed, #ff6a00); }
      .lang-fsharp { background: linear-gradient(135deg, #ee0979, #ffbbff); }
      .lang-julia { background: linear-gradient(135deg, #11998e, #38ef7d); }
      .lang-python { background: linear-gradient(135deg, #3776ab, #ffd43b); }
      .lang-java { background: linear-gradient(135deg, #007396, #ed8b00); }
      .lang-assembly { background: linear-gradient(135deg, #3776ab, #ffd43b); }
    </style>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">

        <!-- Title Slide -->
        <section>
          <h1>Lightweight</h1>
          <h3>ODBC SQL Wrapper Library</h3>
          <p>Thin, fast, and easy-to-use database access for C++</p>
        </section>

        <!-- What is Lightweight -->
        <section>
          <h2>What is Lightweight?</h2>
          <ul>
            <li><strong>Thin ODBC wrapper</strong> for C++23</li>
            <li>Provides <strong>both low-level and high-level</strong> APIs</li>
            <li>Supports multiple databases through ODBC</li>
            <li>Modern C++ features with <strong>type safety</strong></li>
            <li><strong>Experimental C++26 reflection</strong> support</li>
          </ul>
        </section>

        <!-- Authors -->
        <section>
          <h2>Authors</h2>
          <div class="gantt-container">
            <!-- Author 1 -->
            <div class="author-gantt">
              <h3>Christian Parpart</h3>
              <div class="gantt-chart">
                <div class="gantt-header">
                  <span class="gantt-year">91</span>
                  <span class="gantt-year">92</span>
                  <span class="gantt-year">93</span>
                  <span class="gantt-year">94</span>
                  <span class="gantt-year">95</span>
                  <span class="gantt-year">96</span>
                  <span class="gantt-year">97</span>
                  <span class="gantt-year">98</span>
                  <span class="gantt-year">99</span>
                  <span class="gantt-year">00</span>
                  <span class="gantt-year">01</span>
                  <span class="gantt-year">02</span>
                  <span class="gantt-year">03</span>
                  <span class="gantt-year">04</span>
                  <span class="gantt-year">05</span>
                  <span class="gantt-year">06</span>
                  <span class="gantt-year">07</span>
                  <span class="gantt-year">08</span>
                  <span class="gantt-year">09</span>
                  <span class="gantt-year">10</span>
                  <span class="gantt-year">11</span>
                  <span class="gantt-year">12</span>
                  <span class="gantt-year">13</span>
                  <span class="gantt-year">14</span>
                  <span class="gantt-year">15</span>
                  <span class="gantt-year">16</span>
                  <span class="gantt-year">17</span>
                  <span class="gantt-year">18</span>
                  <span class="gantt-year">19</span>
                  <span class="gantt-year">20</span>
                  <span class="gantt-year">21</span>
                  <span class="gantt-year">22</span>
                  <span class="gantt-year">23</span>
                  <span class="gantt-year">24</span>
                  <span class="gantt-year">25</span>
                </div>
                <div class="gantt-row">
                  <span class="gantt-label">C++</span>
                  <div class="gantt-bars">
                    <div class="gantt-bar lang-cpp" style="left: 0%; width: 100%;">C++</div>
                  </div>
                </div>
                <div class="gantt-row">
                  <span class="gantt-label">Assembly</span>
                  <div class="gantt-bars">
                    <div class="gantt-bar lang-assembly" style="left: 5%; width: 20.0%;">Assembly</div>
                  </div>
                </div>
                <div class="gantt-row">
                  <span class="gantt-label">Object Pascal</span>
                  <div class="gantt-bars">
                    <div class="gantt-bar lang-delphi" style="left: 15%; width: 10.0%;">Object Pascal</div>
                  </div>
                </div>
                <div class="gantt-row">
                  <span class="gantt-label">Ruby</span>
                  <div class="gantt-bars">
                    <div class="gantt-bar lang-ruby" style="left: 61%; width: 15.0%;">Ruby</div>
                  </div>
                </div>
                <div class="gantt-row">
                  <span class="gantt-label">F#</span>
                  <div class="gantt-bars">
                    <div class="gantt-bar lang-fsharp" style="left: 76.0%; width: 6%;">F#</div>
                  </div>
                </div>
            </div>
            <!-- Author 2 -->
            <div class="author-gantt">
              <h3>Yaraslau Tamashevich</h3>
              <div class="gantt-chart">
                <div class="gantt-header">
                  <span class="gantt-year">2015</span>
                  <span class="gantt-year">2016</span>
                  <span class="gantt-year">2017</span>
                  <span class="gantt-year">2018</span>
                  <span class="gantt-year">2019</span>
                  <span class="gantt-year">2020</span>
                  <span class="gantt-year">2021</span>
                  <span class="gantt-year">2022</span>
                  <span class="gantt-year">2023</span>
                  <span class="gantt-year">2024</span>
                  <span class="gantt-year">2025</span>
                </div>
                <div class="gantt-row">
                  <span class="gantt-label">Delphi</span>
                  <div class="gantt-bars">
                    <!-- 2015-2017: 0/11 to 3/11 -->
                    <div class="gantt-bar lang-delphi" style="left: 0%; width: 27.3%;">Delphi</div>
                  </div>
                </div>
                <div class="gantt-row">
                  <span class="gantt-label">C++</span>
                  <div class="gantt-bars">
                    <!-- 2019-2020: 4/11 to 6/11 -->
                    <div class="gantt-bar lang-cpp" style="left: 36.4%; width: 18.2%;">C++</div>
                    <!-- 2023-2025: 8/11 to 11/11 -->
                    <div class="gantt-bar lang-cpp" style="left: 72.7%; width: 27.3%;">C++</div>
                  </div>
                </div>
                <div class="gantt-row">
                  <span class="gantt-label">Julia</span>
                  <div class="gantt-bars">
                    <!-- 2021-2025: 6/11 to 11/11 -->
                    <div class="gantt-bar lang-julia" style="left: 54.5%; width: 36%;">Julia</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </section>


        <!-- API Levels -->
        <section>
          <h2>Abstraction layers</h2>
            <ul>
                <li><strong>Low-Level API</strong>: Direct ODBC access</li>
                <ul>
                    <li>Connection</li>
                    <li>Statement execution</li>
                    <li>Result handling</li>
                </ul>
                <li><strong>Query builder</strong>: SQL query construction</li>
                <li><strong>Data Mapper</strong>: Object-relational mapping (ORM) for C++ objects</li>
        </section>

        <!-- Low level api -->
        <section>
          <section>
            <h2>Low Level API: Building blocks</h2>
            <ul>
                <li><strong>SqlStatement</strong>: Main entry point for database communication</li>
            <ul>
                <li>Prepare</li>
                <li>Execute/ExecuteBatch</li>
                <li>Bind</li>
                <li>Fetch</li>
            </ul>
                <li><strong>SqlTransaction</strong>: Transaction handling</li>
                <li><strong>SqlMigration</strong>: Database schema updates</li>
          </section>
          <section>
            <h2>Low Level API: Insert data</h2>
            <pre><code class="language-cpp"  data-line-numbers="|1-2|4-7|"  >SetDefaultConnectionString( { "DRIVER=SQLite3;Database=test.sqlite"});
auto stmt = Lightweight::SqlStatement {};

stmt.Prepare(R"(INSERT INTO "Employees" ("FirstName", "LastName", "Salary") VALUES (?, ?, ?))");
stmt.Execute("Alice", "Smith", 5);
stmt.Execute("Bob", "Johnson", 6);
stmt.Execute("Charlie", "Brown", 7);
            </code></pre>
          </section>
          <section>
          <h2>Low Level API: Fetch data</h2>
          <pre><code class="language-cpp" data-line-numbers="|1-2|4-7|9-15|" >stmt.Prepare(R"(SELECT "FirstName", "LastName", "Salary" FROM "Employees" WHERE "Salary" >= ?)");
stmt.Execute(6);

(void) stmt.FetchRow();
stmt.GetColumn&lt;std::string&gt;(1) // "Bob"
stmt.GetColumn&lt;std::string&gt;(2) // "Johnson"
stmt.GetColumn&lt;int&gt;(3)         // 6

SqlResultCursor cursor = stmt.GetResultCursor();
auto record = Record {};
cursor.BindOutputColumns&lt;Record&gt;(&amp;record.a, &amp;record.b, &amp;record.c);
(void) stmt.FetchRow();
// record.a == "Charlie"
// record.b == "Brown"
// record.c == 7 </code></pre>
          </section>
          <section>
          <h2>Low Level API: How to extend</h2>
          <pre><code class="language-cpp"  data-line-numbers="|1-2|4-12|8-10|13-15|">template &lt;typename&gt;
struct SqlDataBinder;

template &lt;typename T, SQLSMALLINT TheCType, SQLINTEGER TheSqlType, auto TheColumnType&gt;
struct SqlSimpleDataBinder
{
    static constexpr SqlColumnTypeDefinition ColumnType = TheColumnType;
    SQLRETURN InputParameter(..., T const&amp; value,...);
    SQLRETURN OutputColumn(..., T* result, ...)
    SQLRETURN GetColumn(...,T* result, ...)
    std::string Inspect(T value);
};
template &lt;&gt;
struct SqlDataBinder&lt;int32_t&gt;:
    SqlSimpleDataBinder&lt;int32_t, SQL_C_SLONG, SQL_INTEGER, SqlColumnTypeDefinitions::Integer {}&gt; {};</code></pre>
          </section>
          <section>
          <h2>Low Level API: Nullable columns</h2>
          <pre><code class="language-cpp"  data-line-numbers="|1-2|4-13|6-9|">template &lt;typename T&gt;
struct SqlDataBinder&lt;std::optional&lt;T&gt;&gt;
{
    SQLRETURN InputParameter(...,OptionalValue const&amp; value,...)
    {
        if (value.has_value())
            return SqlDataBinder&lt;T&gt;::InputParameter(stmt, column, *value, cb);
        else
            return SqlDataBinder&lt;SqlNullType&gt;::InputParameter(stmt, column, SqlNullValue, cb);
    }
    SQLRETURN OutputColumn(..., T* result, ...)
    SQLRETURN GetColumn(...,T* result, ...)
    std::string Inspect(T value);
};</code></pre>
          </section>

          <section>
          <h2>Low Level API: Some problematic points</h2>
          <pre><code class="language-cpp">template &lt;typename Utf16StringType&gt;
struct SqlDataBinder&lt;Utf16StringType&gt;
{
    static SQLRETURN InputParameter(...) noexcept
    {
        switch (cb.ServerType())
        {
            case SqlServerType::POSTGRESQL: {
                ...
            }
            case SqlServerType::ORACLE:
            case SqlServerType::MYSQL:
            case SqlServerType::SQLITE: // We assume UTF-16 for SQLite
            case SqlServerType::MICROSOFT_SQL:
            case SqlServerType::UNKNOWN: {
                ...
            }
        }
        std::unreachable();
    }
};
</code></pre>
          </section>
        </section>

        <section>
          <section>
            <h2>Query builder</h2>
          </section>
          <section>
                <h2>Query builder: Example</h2>
                <pre><code class="language-cpp">
auto query = stmt.Query().FromTable("That").Select().Fields("foo", "bar")
                 .OrderBy("id").Range(200, 50);
// SELECT "foo", "bar" FROM "That" ORDER BY "id" ASC LIMIT 50 OFFSET 200
stmt.Execute(query);</code></pre>
          </section>
        </section>

        <section>
          <section>
            <h2>Base API</h2>
          <ul>
            <li>Read/Write</li>
            <li>Database independent query building</li>
            <li>Inconvinient to write for complex tasks</li>
          </ul>
            <h3>Solution</h3>
          <ul>
            <li>Generate boilerplate using external tools</li>
            <li>Use variant-like interface without explicit column names</li>
          </ul>
          </section>
        </section>

        <section>
          <section>
            <h2>DataMapper</h2>
          <p>
            Inspired by: <a href="https://github.com/stephenberry/glaze">stephenberry/glaze</a>, a serialization library for C++17 and beyond using compile-time reflection.
          <pre><code class="language-cpp">struct my_struct
{
  int i = 287;
  double d = 3.14;
  std::string hello = "Hello World";
  std::array&lt;uint64_t, 3&gt; arr = { 1, 2, 3 };
  std::map&lt;std::string, int&gt; map{{"one", 1}, {"two", 2}};
};
my_struct s{};
std::string buffer = glz::write_json(s).value_or("error");</code></pre>

          </p>
          Implementation similar to <a href="https://github.com/boostorg/pfr">boostorg/pfr</a>
          <pre><code class="language-cpp">boost::pfr::get&lt;1&gt;(s); // returns int&amp; to my_struct::i</code></pre>

            Similar libraries: <a href="https://github.com/getml/sqlgen"> getml/sqlgen</a>
          </section>

          <section>
            <h2>DataMapper: Load data</h2>
<pre><code class="language-cpp" data-line-numbers="|1|2-3|4-5|6-8|9-10|11-13|" >auto dm = DataMapper();
// Load all Persons
std::vector&lt;Person&gt; users = dm.Query&lt;Person&gt;().All();
// Person with primary key 42
std::optional&lt;Person&gt; user = dm.QuerySingle&lt;Person&gt;(42);
// First user with the name "John"
std::optional&lt;Person&gt; userByName = dm.Query&lt;Person&gt;()
                                    .Where(FieldNameOf&lt;&amp;Person::name&gt;, "=", "John").First();
// Load Persons, but only their ages
std::vector&lt;Person&gt; usersWithAge = dm.Query&lt;Person&gt;().All&lt;&amp;Person::age&gt;();
// Load Persons and Phone Numbers by joining tables
vector&lt;tuple&lt;Person, PhoneNumber&gt;&gt; personsAndPhoneNumbers = dm.Query&lt;Person, PhoneNumber&gt;()
                                     .InnerJoin&lt;&amp;PhoneNumber::personId, &amp;Person::id&gt;().All();</code></pre>
          </section>

          <section>
            <h2>DataMapper: Entity</h2>
            <pre><code class="language-cpp", data-line-numbers="|5|9-16|14-15|">struct Person
{
    Field&lt;Light::SqlGuid, Light::PrimaryKey::AutoAssign&gt; id;
    Field&lt;Light::SqlAnsiString&lt;25&gt;&gt; name;
    Field&lt;bool, SqlRealName { "active" }&gt; is_active { true };
    Field&lt;std::optional&lt;int&gt;&gt; age;
};

template &lt;detail::FieldElementType T, auto P1 = std::nullopt, auto P2 = std::nullopt&gt;
struct Field
{
    [[nodiscard]] constexpr T const&amp; Value() const noexcept;
  private:
    ValueType _value {};
    bool _modified { true };
};
</code></pre>
          </section>

          <section>
            <h2>DataMapper: Foreign key relation</h2>
            <pre><code class="language-cpp", data-line-numbers="|4|7-9|9|" >struct PhoneNumber
{
    // Foreign key to Person
    BelongsTo&lt;&amp;Person::id, Light::SqlRealName{"person_id"}&gt; person;
};

auto number = dm.QuerySingle&lt;PersonNumber&gt;(42).value();
number.person.Value(); // return the value of the foreign key
number.person-&gt;name.Value(); // Lazily loads the related Person entity
</code></pre>
          </section>

          <section>
            <h2>DataMapper: Nullable foreign keys</h2>
            <pre><code class="language-cpp"  data-line-numbers="|1|3-4|6-11|8-9|10|12-13|" >BelongsTo&lt;&amp;Person::id, Light::SqlRealName{"person_id"}, Light::SqlNullable::Null&gt; person;

auto number = dm.QuerySingle&lt;PersonNumber&gt;(42).value();
number.person-&gt;name.Value(); // Might not exist in the database

template &lt;...&gt; class BelongsTo
{
    ReferencedRecord* operator-&gt;(this Self&amp;&amp; self) requires(IsMandatory) {...}
    ReferencedRecord const&amp; Record(this Self&amp;&amp; self) requires(IsMandatory) {...}
    decltype(auto) Record(this Self&amp;&amp; self) requires(IsOptional) {...}
};
// Make sure user knows it might be null
number.person.Record().transform(Light::Unwrap).value_or({}).name;
</code></pre>
          </section>
          <section>
            <h2>DataMapper: Other relations</h2>
            <pre><code class="language-cpp"  data-line-numbers="|2,7,12-13|3,8|" >struct Physician{
    Light::HasMany&lt;Appointment&gt; appointments;
    Light::HasManyThrough&lt;Patient, Appointment&gt; patients;
};

struct Patient{
    Light::HasMany&lt;Appointment&gt; appointments;
    Light::HasManyThrough&lt;Physician, Appointment&gt; physicians;
};

struct Appointment{
    Light::BelongsTo&lt;Member(Physician::id), Light::SqlRealName { "physician_id" }&gt; physician;
    Light::BelongsTo&lt;Member(Patient::id), Light::SqlRealName { "patient_id" }&gt; patient;
};</code></pre>
          </section>

          <section>
            <h2>DataMapper: C++ at it best, Revenge of the Sith</h2>
            <pre><code class="language-cpp"  data-line-numbers="|2-6|8-13|10-11|13|" >
void DataMapper::ConfigureRelationAutoLoading(Record&amp; record){
    field.SetAutoLoader(typename FieldType::Loader {
        .loadReference = [this, &amp;field]() { LoadBelongsTo(field); },
    });
}

Record record{};
{
   auto dm = DataMapper();
   record = dm.QuerySingle&lt;Record&gt;(42).value();
}
record.field-&gt;relatedField.Value();
</code></pre>
          </section>

          <section>
            <h2>DataMapper: C++ at it best, New Hope</h2>
            <pre><code class="language-cpp"  data-line-numbers="|1|3-8|10-15|12-13|15|" >class DataMapper: public std::enable_shared_from_this&lt;DataMapper&gt;{};
void DataMapper::ConfigureRelationAutoLoading(Record&amp; record){
    auto self = shared_from_this();
    field.SetAutoLoader(typename FieldType::Loader {
        .loadReference = [self, value = field.Value()](){
            return self-&gt;LoadBelongsTo&lt;FieldType&gt;(value);
        },
    });
}
Record record{};
{
   std::shared_ptr&lt;DataMapper&gt; dm = DataMapper::Create();
   record = dm-&gt;QuerySingle&lt;Record&gt;(42).value();
}
record.field-&gt;relatedField.Value();
</code></pre>
          </section>

          <section>
            <h2>DataMapper: C++ at it best, The Force Awakens</h2>
            <pre><code class="language-cpp"  data-line-numbers="|2-7|4|9-14|">void DataMapper::ConfigureRelationAutoLoading(Record&amp; record){
    field.SetAutoLoader(typename FieldType::Loader {
        .loadReference = [value = field.Value()]() -&gt; std::optional&lt;typename FieldType::ReferencedRecord&gt; {
            DataMapper&amp; dm = DataMapper::AcquireThreadLocal();
            return dm.LoadBelongsTo&lt;FieldType&gt;(value);
        },
    });
}
Record record{};
{
   auto dm = DataMapper();
   record = dm.QuerySingle&lt;Record&gt;(42).value();
}
record.field-&gt;relatedField.Value();
</code></pre>
          </section>

          </section>


        <!-- ddl2cpp -->
        <section>
          <section>
            <h2>Tools: ddl2cpp</h2>
            <p>Generate C++ code from database schema:</p>
            <pre><code class="language-bash"># Generate models from existing database
Usage: ./ddl2cpp [options] [database] [schema]
Options:
--trace-sql             Enable SQL tracing
--connection-string STR ODBC connection string
--database STR          Database name
--schema STR            Schema name
--create-test-tables    Create test tables
--output STR            Output directory, for every table separate header file will be created
--generate-example      Generate usage example code
using generated header and database connection
--make-aliases          Create aliases for the tables and members
--naming-convention STR Naming convention for aliases
[none, snake_case, camelCase]
--no-warnings           Suppresses warnings
--help, -h              Display this information
            </code></pre>

          </section>
          <section>
            <h3>Generated header file</h3>
            <h4>Track.hpp</h4>
            <pre><code class="language-cpp" data-line-numbers="|3|5-6,10-13|7-9|" >struct Track final
{
    static constexpr std::string_view TableName = "Track";

    Field&lt;int32_t, PrimaryKey::ServerSideAutoIncrement, SqlRealName { "TrackId" }&gt; TrackId;
    Field&lt;SqlDynamicUtf16String&lt;200&gt;, SqlRealName { "Name" }&gt; Name;
    BelongsTo&lt;&amp;Album::AlbumId, SqlRealName { "AlbumId" }, SqlNullable::Null&gt; AlbumId;
    BelongsTo&lt;&amp;Mediatype::MediaTypeId, SqlRealName { "MediaTypeId" }&gt; MediaTypeId;
    BelongsTo&lt;&amp;Genre::GenreId, SqlRealName { "GenreId" }, SqlNullable::Null&gt; GenreId;
    Field&lt;std::optional&lt;SqlDynamicUtf16String&lt;220&gt;&gt;, SqlRealName { "Composer" }&gt; Composer;
    Field&lt;int32_t, SqlRealName { "Milliseconds" }&gt; Milliseconds;
    Field&lt;std::optional&lt;int32_t&gt;, SqlRealName { "Bytes" }&gt; Bytes;
    Field&lt;SqlNumeric&lt;10, 2&gt;, SqlRealName { "UnitPrice" }&gt; UnitPrice;
};
            </code></pre>
          </section>

        </section>

        <section>
          <section>
            <h1>Outlook</h1>
          </section>
          <section>
            <h1>Outlook: C++26 reflection</h1>
            We implemented support for the c++26 reflection, the syntax will change, and instead of `&` user have to use `^^`
<pre><code class="language-cpp" data-line-numbers="" >dm.Query&lt;Person&gt;().All&lt;&amp;Person::age&gt;();
dm.Query&lt;Person&gt;().All&lt;^^Person::age&gt;();</code></pre>
          </section>
          <section>
            <h1>Outlook: Annotations</h1>
            <p>Instead of template arguments, use C++26 annotations for cleaner syntax:</p>
            <pre><code class="language-cpp"  data-line-numbers="|3-4|4,6,8,10,12|3,5,7,9,11|" >struct Track final
{
    [[=PrimaryKey::ServerSideAutoIncrement, =SqlRealName("TrackId")]]
    int32_t TrackId;
    [[=SqlRealName("Name")]]
    SqlDynamicUtf16String&lt;200&gt; Name;
    [[=SqlRealName("AlbumId"), SqlNullable::Null, ]]
    BelongsTo&lt;^^Album::AlbumId&gt; AlbumId;
    [[=SqlRealName("Composer")]]
    std::optional&lt;SqlDynamicUtf16String&lt;220&gt;&gt; Composer;
    [[=SqlRealName("UnitPrice")]]
    SqlNumeric&lt;10, 2&gt; UnitPrice;
};</code></pre>
          </section>
        </section>

        <!-- Thank You -->
        <section>
          <h1>Questions?</h1>
          <p>
            repository: <a href="https://github.com/LASTRADA-Software/Lightweight">github.com/LASTRADA-Software/Lightweight</a>
          </p>
          <p>
            documentation: <a href="https://lastrada-software.github.io/Lightweight">lastrada-software.github.io/Lightweight</a>
          </p>
          <p>
            this presentation: <a href="https://lastrada-software.github.io/Lightweight/presentation">lastrada-software.github.io/Lightweight/presentation</a>
          </p>
        </section>

      </div>
    </div>

    <script src="node_modules/reveal.js/dist/reveal.js"></script>
    <script src="node_modules/reveal.js/plugin/notes/notes.js"></script>
    <script src="node_modules/reveal.js/plugin/markdown/markdown.js"></script>
    <script src="node_modules/reveal.js/plugin/highlight/highlight.js"></script>
    <script src="node_modules/reveal.js/plugin/zoom/zoom.js"></script>
    <script>
      Reveal.initialize({
        width: 1400,
        height: 900,
        margin: 0.04,
        minScale: 0.2,
        maxScale: 2.0,
        hash: true,
        slideNumber: true,
        progress: true,
        history: true,
        center: true,
        transition: 'slide',
        plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealZoom ]
      });
    </script>
  </body>
</html>
