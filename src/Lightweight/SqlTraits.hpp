// SPDX-License-Identifier: Apache-2.0

#pragma once

#include "Api.hpp"

#include <array>
#include <cstdint>
#include <format>
#include <functional>
#include <string_view>

// Represents the type of SQL server, used to determine the correct SQL syntax, if needed.
enum class SqlServerType : uint8_t
{
    UNKNOWN,
    MICROSOFT_SQL,
    POSTGRESQL,
    ORACLE,
    SQLITE,
    MYSQL,
};

enum class SqlColumnType : uint8_t
{
    UNKNOWN,
    CHAR,
    STRING,
    TEXT,
    BOOLEAN,
    SMALLINT,
    INTEGER,
    BIGINT,
    NUMERIC,
    REAL,
    BLOB,
    DATE,
    TIME,
    DATETIME,
    GUID,
};

namespace detail
{

constexpr std::string_view DefaultColumnTypeName(SqlColumnType value) noexcept
{
    switch (value)
    {
        case SqlColumnType::CHAR:
            return "CHAR";
        case SqlColumnType::STRING:
            return "VARCHAR";
        case SqlColumnType::TEXT:
            return "TEXT";
        case SqlColumnType::BOOLEAN:
            return "BOOL";
        case SqlColumnType::SMALLINT:
            return "SMALLINT";
        case SqlColumnType::INTEGER:
            return "INTEGER";
        case SqlColumnType::BIGINT:
            return "BIGINT";
        case SqlColumnType::NUMERIC:
            return "NUMERIC";
        case SqlColumnType::REAL:
            return "REAL";
        case SqlColumnType::BLOB:
            return "BLOB";
        case SqlColumnType::DATE:
            return "DATE";
        case SqlColumnType::TIME:
            return "TIME";
        case SqlColumnType::DATETIME:
            // With SQL Server or Oracle, we could use DATETIME2(7) and have nano-second precision (with 100ns
            // resolution) The standard DATETIME and ODBC SQL_TIMESTAMP have only millisecond precision.
            return "DATETIME";
        case SqlColumnType::GUID:
            return "BINARY(16)";
        case SqlColumnType::UNKNOWN:
            break;
    }
    return "UNKNOWN";
}

} // namespace detail

struct SqlTraits
{
    std::string_view PrimaryKeyAutoIncrement; // Maybe rename this to `PrimaryKeyIdentityColumnType`?
    std::string_view PrimaryKeyGuidColumnType;
    std::string_view CurrentTimestampExpr;
    std::string_view EnforceForeignKeyConstraint;
    size_t MaxStatementLength {};
    std::function<std::string_view(SqlColumnType)> ColumnTypeName;
};

namespace detail
{

inline SqlTraits const MicrosoftSqlTraits {
    .PrimaryKeyAutoIncrement = "INT IDENTITY(1,1) PRIMARY KEY",
    .PrimaryKeyGuidColumnType = "UNIQUEIDENTIFIER PRIMARY KEY DEFAULT NEWID()",
    .CurrentTimestampExpr = "GETDATE()",
    .EnforceForeignKeyConstraint = "",
    .ColumnTypeName = [](SqlColumnType value) -> std::string_view {
        switch (value)
        {
            case SqlColumnType::TEXT:
                return "VARCHAR(MAX)";
            case SqlColumnType::BOOLEAN:
                return "BIT";
            case SqlColumnType::GUID:
                return "UNIQUEIDENTIFIER";
            default:
                return DefaultColumnTypeName(value);
        }
    },
};

inline SqlTraits const PostgresSqlTraits {
    .PrimaryKeyAutoIncrement = "SERIAL PRIMARY KEY",
    .PrimaryKeyGuidColumnType = "UUID PRIMARY KEY DEFAULT gen_random_uuid()",
    .CurrentTimestampExpr = "CURRENT_TIMESTAMP",
    .EnforceForeignKeyConstraint = "",
    .ColumnTypeName = [](SqlColumnType value) -> std::string_view {
        switch (value)
        {
            case SqlColumnType::GUID:
                return "UUID";
            case SqlColumnType::DATETIME:
                return "TIMESTAMP";
            default:
                return detail::DefaultColumnTypeName(value);
        }
    },
};

inline SqlTraits const OracleSqlTraits {
    .PrimaryKeyAutoIncrement = "NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY",
    .PrimaryKeyGuidColumnType = "RAW(16) PRIMARY KEY DEFAULT SYS_GUID()",
    .CurrentTimestampExpr = "SYSTIMESTAMP",
    .EnforceForeignKeyConstraint = "",
    .ColumnTypeName = [](SqlColumnType value) -> std::string_view {
        switch (value)
        {
            case SqlColumnType::DATETIME:
                return "TIMESTAMP";
            case SqlColumnType::GUID:
                return "RAW(16)";
            case SqlColumnType::SMALLINT:
                return "NUMBER";
            case SqlColumnType::INTEGER:
                return "NUMBER";
            case SqlColumnType::BIGINT:
                return "NUMBER";
            default:
                return detail::DefaultColumnTypeName(value);
        }
    },
};

inline SqlTraits const SQLiteTraits {
    .PrimaryKeyAutoIncrement = "INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT",
    .PrimaryKeyGuidColumnType = "GUID PRIMARY KEY DEFAULT (lower(hex(randomblob(16))))",
    .CurrentTimestampExpr = "CURRENT_TIMESTAMP",
    .EnforceForeignKeyConstraint = "PRAGMA foreign_keys = ON",
    .ColumnTypeName = [](SqlColumnType value) -> std::string_view {
        switch (value)
        {
            case SqlColumnType::GUID:
                return "GUID";
            default:
                return detail::DefaultColumnTypeName(value);
        }
    },
};

inline SqlTraits const MySQLTraits {
    .PrimaryKeyAutoIncrement = "INT AUTO_INCREMENT PRIMARY KEY",
    .PrimaryKeyGuidColumnType = "BINARY(16) PRIMARY KEY DEFAULT UUID_TO_BIN(UUID())",
    .CurrentTimestampExpr = "NOW()",
    .EnforceForeignKeyConstraint = "",
    .ColumnTypeName = detail::DefaultColumnTypeName,
};

inline SqlTraits const UnknownSqlTraits {
    .PrimaryKeyAutoIncrement = "",
    .PrimaryKeyGuidColumnType = "BINARY(16) PRIMARY KEY",
    .CurrentTimestampExpr = "",
    .EnforceForeignKeyConstraint = "",
    .ColumnTypeName = detail::DefaultColumnTypeName,
};

} // namespace detail

inline SqlTraits const& GetSqlTraits(SqlServerType serverType) noexcept
{
    auto static const sqlTraits = std::array {
        &detail::UnknownSqlTraits, &detail::MicrosoftSqlTraits, &detail::PostgresSqlTraits,
        &detail::OracleSqlTraits,  &detail::SQLiteTraits,
    };

    return *sqlTraits[static_cast<size_t>(serverType)];
}

template <>
struct LIGHTWEIGHT_API std::formatter<SqlServerType>: std::formatter<std::string_view>
{
    auto format(SqlServerType type, format_context& ctx) const -> format_context::iterator
    {
        string_view name;
        switch (type)
        {
            case SqlServerType::MICROSOFT_SQL:
                name = "Microsoft SQL Server";
                break;
            case SqlServerType::POSTGRESQL:
                name = "PostgreSQL";
                break;
            case SqlServerType::ORACLE:
                name = "Oracle";
                break;
            case SqlServerType::SQLITE:
                name = "SQLite";
                break;
            case SqlServerType::MYSQL:
                name = "MySQL";
                break;
            case SqlServerType::UNKNOWN:
                name = "Unknown";
                break;
        }
        return std::formatter<string_view>::format(name, ctx);
    }
};
