// SPDX-License-Identifier: Apache-2.0

#include "CodeGenerator.hpp"

#include <algorithm>
#include <cctype>
#include <format>
#include <optional>
#include <regex>
#include <unordered_map>

namespace Lup2DbTool
{

namespace
{

    std::string ToUpper(std::string_view str)
    {
        std::string result(str);
        std::ranges::transform(result, result.begin(), [](unsigned char c) { return static_cast<char>(std::toupper(c)); });
        return result;
    }

    std::string EscapeCppString(std::string_view str)
    {
        std::string result;
        result.reserve(str.size() + 10);
        for (char c: str)
        {
            switch (c)
            {
                case '\\':
                    result += "\\\\";
                    break;
                case '"':
                    result += "\\\"";
                    break;
                case '\n':
                    result += "\\n";
                    break;
                case '\r':
                    result += "\\r";
                    break;
                case '\t':
                    result += "\\t";
                    break;
                default:
                    result += c;
                    break;
            }
        }
        return result;
    }

    bool IsNumericValue(std::string_view value)
    {
        if (value.empty())
            return false;

        // Skip leading negative sign
        size_t start = 0;
        if (value[0] == '-' || value[0] == '+')
            start = 1;

        if (start >= value.size())
            return false;

        bool hasDot = false;
        for (size_t i = start; i < value.size(); ++i)
        {
            if (value[i] == '.')
            {
                if (hasDot)
                    return false;
                hasDot = true;
            }
            else if (!std::isdigit(static_cast<unsigned char>(value[i])))
            {
                return false;
            }
        }
        return true;
    }

    bool IsStringLiteral(std::string_view value)
    {
        if (value.size() < 2)
            return false;
        return (value.front() == '\'' && value.back() == '\'');
    }

    std::string StripQuotes(std::string_view value)
    {
        if (value.size() >= 2
            && ((value.front() == '\'' && value.back() == '\'') || (value.front() == '"' && value.back() == '"')))
        {
            return std::string(value.substr(1, value.size() - 2));
        }
        return std::string(value);
    }

} // namespace

CodeGenerator::CodeGenerator(CodeGeneratorConfig config):
    _config(std::move(config))
{
}

void CodeGenerator::WriteFileHeader(std::ostream& out) const
{
    out << "// Auto-generated by lup2dbtool\n";
    out << "// DO NOT EDIT - Regenerate using: lup2dbtool --input-dir ...\n";
    out << "\n";
    out << "#include <Lightweight/SqlMigration.hpp>\n";
    out << "\n";
    out << "using namespace Lightweight;\n";
    out << "using namespace Lightweight::SqlMigration;\n";
    out << "using namespace SqlColumnTypeDefinitions;\n";
    out << "\n";
    out << "namespace " << _config.namespacePrefix << "\n";
    out << "{\n";
    out << "\n";
}

void CodeGenerator::WriteFileFooter(std::ostream& out) const
{
    out << "} // namespace " << _config.namespacePrefix << "\n";
}

// NOLINTNEXTLINE(readability-convert-member-functions-to-static)
void CodeGenerator::GenerateMigration(ParsedMigration const& migration, std::ostream& out) const
{
    auto timestamp = migration.targetVersion.ToMigrationTimestamp();
    auto title = EscapeCppString(migration.title);

    out << "// " << std::string(76, '=') << "\n";
    out << "// Migration: " << migration.sourceFile.filename().string() << "\n";
    if (migration.baseVersion)
    {
        out << "// Based on LUP Version " << migration.baseVersion->major << "." << migration.baseVersion->minor << "."
            << migration.baseVersion->patch << "\n";
    }
    out << "// Target: LUP Version " << migration.targetVersion.major << "." << migration.targetVersion.minor << "."
        << migration.targetVersion.patch << "\n";
    out << "// " << std::string(76, '=') << "\n";

    out << "LIGHTWEIGHT_SQL_MIGRATION(" << timestamp << ", \"" << title << "\")\n";
    out << "{\n";

    for (auto const& stmtWithComments: migration.statements)
    {
        // Write comments
        for (auto const& comment: stmtWithComments.comments)
        {
            // Skip directive comments
            if (comment.find("Based on Lup Version") != std::string::npos)
                continue;
            if (comment.find("LUP-Version:") != std::string::npos)
                continue;
            if (comment.starts_with("print "))
                continue;

            out << "    // " << comment << "\n";
        }

        WriteStatementCode(stmtWithComments.statement, out, "    ");
    }

    out << "}\n\n";
}

void CodeGenerator::GenerateAllMigrations(std::vector<ParsedMigration> const& migrations, std::ostream& out) const
{
    WriteFileHeader(out);

    for (auto const& migration: migrations)
        GenerateMigration(migration, out);

    WriteFileFooter(out);
}

void CodeGenerator::WriteStatementCode(ParsedStatement const& stmt, std::ostream& out, std::string const& indent)
{
    std::visit(
        [&](auto const& s) {
            using T = std::decay_t<decltype(s)>;
            if constexpr (std::is_same_v<T, CreateTableStmt>)
                WriteCreateTable(s, out, indent);
            else if constexpr (std::is_same_v<T, AlterTableAddColumnStmt>)
                WriteAlterTableAddColumn(s, out, indent);
            else if constexpr (std::is_same_v<T, AlterTableAddForeignKeyStmt>)
                WriteAlterTableAddForeignKey(s, out, indent);
            else if constexpr (std::is_same_v<T, AlterTableAddCompositeForeignKeyStmt>)
                WriteAlterTableAddCompositeForeignKey(s, out, indent);
            else if constexpr (std::is_same_v<T, AlterTableDropForeignKeyStmt>)
                WriteAlterTableDropForeignKey(s, out, indent);
            else if constexpr (std::is_same_v<T, CreateIndexStmt>)
                WriteCreateIndex(s, out, indent);
            else if constexpr (std::is_same_v<T, DropTableStmt>)
                WriteDropTable(s, out, indent);
            else if constexpr (std::is_same_v<T, InsertStmt>)
                WriteInsert(s, out, indent);
            else if constexpr (std::is_same_v<T, UpdateStmt>)
                WriteUpdate(s, out, indent);
            else if constexpr (std::is_same_v<T, DeleteStmt>)
                WriteDelete(s, out, indent);
            else if constexpr (std::is_same_v<T, RawSqlStmt>)
                WriteRawSql(s, out, indent);
        },
        stmt);
}

void CodeGenerator::WriteCreateTable(CreateTableStmt const& stmt, std::ostream& out, std::string const& indent)
{
    out << indent << "plan.CreateTable(\"" << stmt.tableName << "\")\n";

    for (auto const& col: stmt.columns)
    {
        auto cppType = MapSqlType(col.type);
        if (col.isPrimaryKey)
        {
            out << indent << "    .PrimaryKey(\"" << col.name << "\", " << cppType << ")\n";
        }
        else if (col.isNullable)
        {
            out << indent << "    .Column(\"" << col.name << "\", " << cppType << ")\n";
        }
        else
        {
            out << indent << "    .RequiredColumn(\"" << col.name << "\", " << cppType << ")\n";
        }
    }

    // Note: Foreign keys in CREATE TABLE are handled via ForeignKey method on SqlCreateTableQueryBuilder
    for (auto const& fk: stmt.foreignKeys)
    {
        out << indent << "    .ForeignKey({\"" << fk.columnName << "\"}, \"" << fk.referencedTable << "\", {\""
            << fk.referencedColumn << "\"})\n";
    }

    out << indent << "    ;\n";
}

void CodeGenerator::WriteAlterTableAddColumn(AlterTableAddColumnStmt const& stmt,
                                             std::ostream& out,
                                             std::string const& indent)
{
    auto cppType = MapSqlType(stmt.column.type);

    out << indent << "plan.AlterTable(\"" << stmt.tableName << "\")\n";
    if (stmt.column.isNullable)
    {
        out << indent << "    .AddNotRequiredColumn(\"" << stmt.column.name << "\", " << cppType << ");\n";
    }
    else
    {
        out << indent << "    .AddColumn(\"" << stmt.column.name << "\", " << cppType << ");\n";
    }
}

void CodeGenerator::WriteAlterTableAddForeignKey(AlterTableAddForeignKeyStmt const& stmt,
                                                 std::ostream& out,
                                                 std::string const& indent)
{
    out << indent << "plan.AlterTable(\"" << stmt.tableName << "\")\n";
    out << indent << "    .AddForeignKey(\"" << stmt.foreignKey.columnName << "\", {.tableName = \""
        << stmt.foreignKey.referencedTable << "\", .columnName = \"" << stmt.foreignKey.referencedColumn << "\"});\n";
}

void CodeGenerator::WriteAlterTableAddCompositeForeignKey(AlterTableAddCompositeForeignKeyStmt const& stmt,
                                                          std::ostream& out,
                                                          std::string const& indent)
{
    out << indent << "plan.AlterTable(\"" << stmt.tableName << "\")\n";
    out << indent << "    .AddCompositeForeignKey({";
    for (size_t i = 0; i < stmt.columns.size(); ++i)
    {
        if (i > 0)
            out << ", ";
        out << "\"" << stmt.columns[i] << "\"";
    }
    out << "}, \"" << stmt.referencedTable << "\", {";
    for (size_t i = 0; i < stmt.referencedColumns.size(); ++i)
    {
        if (i > 0)
            out << ", ";
        out << "\"" << stmt.referencedColumns[i] << "\"";
    }
    out << "});\n";
}

void CodeGenerator::WriteAlterTableDropForeignKey(AlterTableDropForeignKeyStmt const& stmt,
                                                  std::ostream& out,
                                                  std::string const& indent)
{
    out << indent << "plan.AlterTable(\"" << stmt.tableName << "\")\n";
    out << indent << "    .DropForeignKey(\"" << stmt.columnName << "\");\n";
}

void CodeGenerator::WriteCreateIndex(CreateIndexStmt const& stmt, std::ostream& out, std::string const& indent)
{
    char const* const methodName = stmt.unique ? "CreateUniqueIndex" : "CreateIndex";

    out << indent << "plan." << methodName << "(\"" << stmt.indexName << "\", \"" << stmt.tableName << "\", {";
    for (size_t i = 0; i < stmt.columns.size(); ++i)
    {
        if (i > 0)
            out << ", ";
        out << "\"" << stmt.columns[i] << "\"";
    }
    out << "});\n";
}

void CodeGenerator::WriteDropTable(DropTableStmt const& stmt, std::ostream& out, std::string const& indent)
{
    out << indent << "plan.DropTable(\"" << stmt.tableName << "\");\n";
}

void CodeGenerator::WriteInsert(InsertStmt const& stmt, std::ostream& out, std::string const& indent)
{
    out << indent << "plan.Insert(\"" << stmt.tableName << "\")\n";

    for (size_t i = 0; i < stmt.columnValues.size(); ++i)
    {
        auto const& [col, val] = stmt.columnValues[i];
        auto formattedValue = FormatValueLiteral(val);
        out << indent << "    .Set(\"" << col << "\", " << formattedValue << ")";
        if (i + 1 < stmt.columnValues.size())
            out << "\n";
        else
            out << ";\n";
    }
}

void CodeGenerator::WriteUpdate(UpdateStmt const& stmt, std::ostream& out, std::string const& indent)
{
    out << indent << "plan.Update(\"" << stmt.tableName << "\")\n";

    for (auto const& [col, val]: stmt.setColumns)
    {
        auto formattedValue = FormatValueLiteral(val);
        out << indent << "    .Set(\"" << col << "\", " << formattedValue << ")\n";
    }

    if (!stmt.whereColumn.empty())
    {
        auto formattedValue = FormatValueLiteral(stmt.whereValue);
        out << indent << "    .Where(\"" << stmt.whereColumn << "\", \"" << stmt.whereOp << "\", " << formattedValue
            << ");\n";
    }
    else
    {
        // Remove trailing newline and add semicolon
        out << indent << "    ;\n";
    }
}

void CodeGenerator::WriteDelete(DeleteStmt const& stmt, std::ostream& out, std::string const& indent)
{
    out << indent << "plan.Delete(\"" << stmt.tableName << "\")";

    if (!stmt.whereColumn.empty())
    {
        auto formattedValue = FormatValueLiteral(stmt.whereValue);
        out << "\n"
            << indent << "    .Where(\"" << stmt.whereColumn << "\", \"" << stmt.whereOp << "\", " << formattedValue
            << ");\n";
    }
    else
    {
        out << ";\n";
    }
}

void CodeGenerator::WriteRawSql(RawSqlStmt const& stmt, std::ostream& out, std::string const& indent)
{
    auto escaped = EscapeCppString(stmt.sql);
    out << indent << "plan.RawSql(\"" << escaped << "\");\n";
}

namespace
{
    std::optional<std::string> MapParameterizedType(std::string_view basetype,
                                                    std::string const& param1,
                                                    std::string const& param2)
    {
        auto upper = ToUpper(basetype);
        if (upper == "VARCHAR")
            return std::format("Varchar({})", param1);
        if (upper == "NVARCHAR")
            return std::format("NVarchar({})", param1);
        if (upper == "CHAR")
            return std::format("Char({})", param1);
        if (upper == "NCHAR")
            return std::format("NChar({})", param1);
        if (upper == "DECIMAL" || upper == "NUMERIC")
            return param2.empty() ? std::format("Decimal({})", param1) : std::format("Decimal({}, {})", param1, param2);
        if (upper == "VARBINARY")
            return std::format("VarBinary({})", param1);
        return std::nullopt;
    }

    std::optional<std::string> MapSimpleType(std::string_view upper)
    {
        static std::unordered_map<std::string, std::string> const typeMap = {
            { "INTEGER", "Integer()" },   { "INT", "Integer()" },        { "SMALLINT", "Smallint()" },
            { "BIGINT", "Bigint()" },     { "REAL", "Real()" },          { "FLOAT", "Real()" },
            { "DOUBLE", "Real()" },       { "TEXT", "Text()" },          { "LONG VARCHAR", "Text()" },
            { "DATETIME", "DateTime()" }, { "TIMESTAMP", "DateTime()" }, { "DATE", "Date()" },
            { "TIME", "Time()" },         { "BOOLEAN", "Bool()" },       { "BOOL", "Bool()" },
            { "BIT", "Bool()" },          { "GUID", "Guid()" },          { "UNIQUEIDENTIFIER", "Guid()" },
        };

        auto it = typeMap.find(std::string(upper));
        if (it != typeMap.end())
            return it->second;
        return std::nullopt;
    }
} // namespace

std::string CodeGenerator::MapSqlType(std::string_view sqlType)
{
    auto upper = ToUpper(sqlType);

    // Handle types with parameters (e.g., VARCHAR(255))
    std::regex typeWithParam(R"((\w+)\s*\(\s*(\d+)\s*(?:,\s*(\d+))?\s*\))", std::regex::icase);
    std::smatch match;
    std::string typeStr(sqlType);

    if (std::regex_match(typeStr, match, typeWithParam))
    {
        if (auto result = MapParameterizedType(match[1].str(), match[2].str(), match[3].str()))
            return *result;
    }

    // Handle simple types
    if (auto result = MapSimpleType(upper))
        return *result;

    // Fallback - return as-is with parentheses (may need manual adjustment)
    return std::format("/* TODO: {} */ Text()", sqlType);
}

std::string CodeGenerator::FormatValueLiteral(std::string_view value)
{
    auto upper = ToUpper(value);

    // NULL value
    if (upper == "NULL")
        return "SqlNullValue";

    // Numeric value
    if (IsNumericValue(value))
        return std::string(value);

    // String literal
    if (IsStringLiteral(value))
    {
        auto stripped = StripQuotes(value);
        return std::format("\"{}\"", EscapeCppString(stripped));
    }

    // Default - treat as string
    return std::format("\"{}\"", EscapeCppString(value));
}

std::string ResolveOutputPattern(std::string_view pattern, LupVersion const& version)
{
    std::string result(pattern);

    // Replace {major}, {minor}, {patch}
    result = std::regex_replace(result, std::regex(R"(\{major\})"), std::to_string(version.major));
    result = std::regex_replace(result, std::regex(R"(\{minor\})"), std::format("{:02}", version.minor));
    result = std::regex_replace(result, std::regex(R"(\{patch\})"), std::format("{:02}", version.patch));
    result = std::regex_replace(result, std::regex(R"(\{version\})"), version.ToString());

    return result;
}

bool IsMultiFilePattern(std::string_view pattern)
{
    return pattern.find("{major}") != std::string_view::npos || pattern.find("{minor}") != std::string_view::npos
           || pattern.find("{patch}") != std::string_view::npos || pattern.find("{version}") != std::string_view::npos;
}

} // namespace Lup2DbTool
